display mode: cube using GLUT
  18.12 sec
display mode: cube using quadrilaterals
  18.04 sec
display mode: cube using quadrilateral arrays
  18.05 sec
display mode: cone using GLUT
  18.01 sec
display mode: cone using triangles
  18.05 sec
display mode: cone using triangle arrays
  18.08 sec
display mode: cone using calculated triangles
  18.12 sec
display mode: VRML objects
  cube: 18.03 sec
  dodecahedron: 18.01 sec
  icosahedron: 18.02 sec
  pyramid: 18.01 sec
display mode: freeform scene
  18.01 sec

5.  Describe a reasonable alternative to the line equation representation y=mx+b for use in displaying a line segment on the screen. What are its advantages over ax+by+c=0?

6.  Suppose I want to transform as follows: translate (2,3,1), then rotate 225 degrees about Y, and finally translate (-4,1,0). What will my final transformation matrix be?

1. Lets say you have an array of vertices
Point3 vertices[num]; //assume that Point3 is some arbitrary representation of a vertex
I'm also assuming that you are given an array of vertex indices
int indices[num_indices]; where each combination of indices that compose the element are separated by a -1 value.
In order to draw an object representation using these vertex indices, for each index, go to that point in the vertices array and draw it. Create a line loop/other shape using those indexed vertices. 
The original array does not change, it only gets indexed. 
You don't really need any additional data structures. 

2. There are four matrix modes: 
a) model-view -> used to position the camera and build models of objects
b) projection -> used to define the view volume and to select a camera lens
c) texture -> control texture coordinates and project texture
d) color -> control vertex colors

3.  in order to get the desired view, draw the scene three times. 
Move the camera in the +z direction to view the object in such a way that it is 1/4th of the screen.
Draw the object three separate times, and rotate/translate accordingly in order to get the desired views.
for the front view, just translate the object up and to the left
for the side view, perform a rotation on the z plane and translate the object up and to the right 
for the top view, perform a rotation on the y plane and translate the object down and to the left/right

4. A single frame buffer can be used for images, and nonmoving parts. But, sometimes if you have moving images, the image can be written over in the buffer before it is displayed completely, displaying a broken look. In these situations, it is beneficial to use a double frame buffer, so while one buffer (the front buffer) is being displayed, the other buffer (the back buffer) is being drawn into and is available for constructing what we would like to display next.

5. A reasonable alternative to displaying a line segment on the screen is to simply have a point, P(x,y,z,1) and a vector Q(x',y',z', 0). In this way, you can express a line by simply starting at the point and moving in the direction of a vector. using the y = mx+b formula is better than the ax+by+c=0 formula because it is much easier to generate points with the y=mx+b. 

6. 
translate (2,3,1)
[x']    [1 0 0 2][x]
[y']  = [0 1 0 3][y] 
[z']    [0 0 1 1][z]
[1 ]    [0 0 0 1][1]
rotate 225 deg around y
[x'']   [1    0       0     0][x']
[y''] = [0 cos225 -sin225   0][y']
[z'']	[0 sin225  cos225   0][z']	
[1  ]   [0    0       0     1][1 ]
translate (-4,1,0)
[x''']  [1 0 0 -4][x'']
[y'''] =[0 1 0  1][y''] 
[z''']  [0 0 0  0][z'']
[1   ]  [0 0 0  1][1  ]

after combining you get a final matrix of:
[x''']   [1   0       0            -2           ][x]
[y'''] = [0 cos225 -sin225 3(cos225)+(-sin225)+1][y]
[z''']   [0 sin225  cos225  3(sin225) + (cos225)][z]
[1   ]   [0   0       0             1           ][1]







 
